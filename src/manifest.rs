use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ManifestEntry {
    Symlink,
    Copy,
    Rendered,
}

#[derive(Debug, Default, Serialize, Deserialize)]
pub struct Manifest {
    #[serde(default)]
    pub files: BTreeMap<String, ManifestEntry>,
}

impl Manifest {
    pub fn load(repo_path: &Path) -> Result<Self> {
        let manifest_path = Self::path_for_repo(repo_path);

        if !manifest_path.exists() {
            return Ok(Self::default());
        }

        let content = fs::read_to_string(&manifest_path)
            .with_context(|| format!("Failed to read manifest: {}", manifest_path.display()))?;

        toml::from_str(&content)
            .with_context(|| format!("Failed to parse manifest: {}", manifest_path.display()))
    }

    pub fn save(&self, repo_path: &Path) -> Result<()> {
        let manifest_path = Self::path_for_repo(repo_path);

        let homie_dir = repo_path.join(".homie");
        if !homie_dir.exists() {
            fs::create_dir_all(&homie_dir)
                .with_context(|| format!("Failed to create .homie dir: {}", homie_dir.display()))?;
        }

        let content = format!(
            "# Auto-generated by homie. Do not edit manually.\n{}",
            toml::to_string_pretty(self).context("Failed to serialize manifest")?
        );

        let temp_path = manifest_path.with_extension("toml.tmp");
        fs::write(&temp_path, &content)
            .with_context(|| format!("Failed to write temp manifest: {}", temp_path.display()))?;

        fs::rename(&temp_path, &manifest_path)
            .with_context(|| format!("Failed to rename manifest: {}", manifest_path.display()))?;

        Ok(())
    }

    pub fn path_for_repo(repo_path: &Path) -> PathBuf {
        repo_path.join(".homie/manifest.toml")
    }

    pub fn insert(&mut self, relative_path: String, entry: ManifestEntry) {
        self.files.insert(relative_path, entry);
    }

    #[allow(dead_code)]
    pub fn remove(&mut self, relative_path: &str) {
        self.files.remove(relative_path);
    }

    #[allow(dead_code)]
    pub fn get(&self, relative_path: &str) -> Option<ManifestEntry> {
        self.files.get(relative_path).copied()
    }

    pub fn is_empty(&self) -> bool {
        self.files.is_empty()
    }

    pub fn iter(&self) -> impl Iterator<Item = (&String, &ManifestEntry)> {
        self.files.iter()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_manifest_load_nonexistent() {
        let temp = TempDir::new().unwrap();
        let manifest = Manifest::load(temp.path()).unwrap();
        assert!(manifest.files.is_empty());
    }

    #[test]
    fn test_manifest_save_and_load() {
        let temp = TempDir::new().unwrap();
        let mut manifest = Manifest::default();
        manifest.insert(".zshrc".to_string(), ManifestEntry::Symlink);
        manifest.insert(".config/app/settings.json".to_string(), ManifestEntry::Copy);
        manifest.insert(".gitconfig".to_string(), ManifestEntry::Rendered);

        manifest.save(temp.path()).unwrap();

        let loaded = Manifest::load(temp.path()).unwrap();
        assert_eq!(loaded.files.len(), 3);
        assert_eq!(loaded.get(".zshrc"), Some(ManifestEntry::Symlink));
        assert_eq!(loaded.get(".config/app/settings.json"), Some(ManifestEntry::Copy));
        assert_eq!(loaded.get(".gitconfig"), Some(ManifestEntry::Rendered));
    }

    #[test]
    fn test_manifest_path() {
        let repo_path = PathBuf::from("/home/user/.homie/repos/dotfiles");
        let manifest_path = Manifest::path_for_repo(&repo_path);
        assert_eq!(
            manifest_path,
            PathBuf::from("/home/user/.homie/repos/dotfiles/.homie/manifest.toml")
        );
    }

    #[test]
    fn test_manifest_remove() {
        let mut manifest = Manifest::default();
        manifest.insert(".zshrc".to_string(), ManifestEntry::Symlink);
        assert!(manifest.get(".zshrc").is_some());

        manifest.remove(".zshrc");
        assert!(manifest.get(".zshrc").is_none());
    }
}
